#!/usr/bin/env bash
# Generate RESULTS.md from hyperfine JSON output
# Usage: ./benchmarks/generate-report.sh render.json git.json > RESULTS.md
# Requires: jq

set -euo pipefail

RENDER_JSON="${1:?Usage: generate-report.sh render.json git.json}"
GIT_JSON="${2:?Usage: generate-report.sh render.json git.json}"

if ! command -v jq >/dev/null 2>&1; then
  echo "jq required" >&2
  exit 1
fi

# Extract data from hyperfine JSON
# Each result has: command, mean, stddev, min, max, median
extract_results() {
  local json="$1"
  jq -r '.results[] | [.command, .mean, .stddev, .min, .max, .median] | @tsv' "$json"
}

# Format milliseconds with 1 decimal
fmt_ms() {
  local sec="$1"
  # Use awk for float math (no bc dependency)
  awk "BEGIN { printf \"%.1f\", $sec * 1000 }"
}

# Generate bar (Unicode block chars)
# $1=value (seconds), $2=max_value (seconds), $3=max_width (chars)
bar() {
  local val="$1" max_val="$2" max_width="${3:-30}"
  if [ "$max_val" = "0" ]; then echo ""; return; fi
  local width
  width=$(awk "BEGIN { w = int($val / $max_val * $max_width + 0.5); if (w < 1) w = 1; print w }")
  local bar=""
  local i
  for ((i = 0; i < width; i++)); do bar="${bar}█"; done
  echo "$bar"
}

# Header
cat <<'HEADER'
# Benchmark Results

Engine performance comparison measured with [hyperfine](https://github.com/sharkdp/hyperfine).

> Auto-generated by CI. Do not edit manually.
> Hardware: GitHub Actions `ubuntu-latest` (2-core x86_64).
> Each benchmark: 5 warmup runs, 50+ measured runs.

HEADER

# --- Render-only table ---
echo "## Render Only (no git)"
echo ""
echo "Pure rendering speed — JSON parsing, formatting, ANSI output. Git and cumulative stats disabled."
echo ""

# Collect render data
declare -a R_NAMES=() R_MEANS=() R_STDDEVS=() R_MINS=() R_MAXS=()
MAX_RENDER=0

while IFS=$'\t' read -r name mean stddev min max _median; do
  R_NAMES+=("$name")
  R_MEANS+=("$mean")
  R_STDDEVS+=("$stddev")
  R_MINS+=("$min")
  R_MAXS+=("$max")
  # Track max for bar scaling
  is_bigger=$(awk "BEGIN { print ($mean > $MAX_RENDER) }")
  if [ "$is_bigger" = "1" ]; then MAX_RENDER="$mean"; fi
done < <(extract_results "$RENDER_JSON")

echo "| Engine | Mean | σ | Min | Max | |"
echo "|--------|-----:|--:|----:|----:|---|"

for i in "${!R_NAMES[@]}"; do
  name="${R_NAMES[$i]}"
  mean_ms=$(fmt_ms "${R_MEANS[$i]}")
  std_ms=$(fmt_ms "${R_STDDEVS[$i]}")
  min_ms=$(fmt_ms "${R_MINS[$i]}")
  max_ms=$(fmt_ms "${R_MAXS[$i]}")
  chart=$(bar "${R_MEANS[$i]}" "$MAX_RENDER" 30)
  printf "| **%s** | %sms | ±%sms | %sms | %sms | \`%s\` |\n" \
    "$name" "$mean_ms" "$std_ms" "$min_ms" "$max_ms" "$chart"
done

echo ""

# Relative comparison for render
if [ ${#R_NAMES[@]} -ge 2 ]; then
  # Find fastest
  fastest_idx=0
  fastest_mean="${R_MEANS[0]}"
  for i in "${!R_MEANS[@]}"; do
    is_faster=$(awk "BEGIN { print (${R_MEANS[$i]} < $fastest_mean) }")
    if [ "$is_faster" = "1" ]; then
      fastest_idx=$i
      fastest_mean="${R_MEANS[$i]}"
    fi
  done

  echo "<details>"
  echo "<summary>Relative speed</summary>"
  echo ""
  for i in "${!R_NAMES[@]}"; do
    ratio=$(awk "BEGIN { printf \"%.1f\", ${R_MEANS[$i]} / $fastest_mean }")
    if [ "$i" = "$fastest_idx" ]; then
      echo "- **${R_NAMES[$i]}**: baseline (fastest)"
    else
      echo "- **${R_NAMES[$i]}**: ${ratio}x slower"
    fi
  done
  echo ""
  echo "</details>"
  echo ""
fi

# --- Git table ---
echo "## With Git Operations"
echo ""
echo "Full render including git branch, dirty check, ahead/behind, stash count. Cumulative stats disabled."
echo ""

declare -a G_NAMES=() G_MEANS=() G_STDDEVS=() G_MINS=() G_MAXS=()
MAX_GIT=0

while IFS=$'\t' read -r name mean stddev min max _median; do
  G_NAMES+=("$name")
  G_MEANS+=("$mean")
  G_STDDEVS+=("$stddev")
  G_MINS+=("$min")
  G_MAXS+=("$max")
  is_bigger=$(awk "BEGIN { print ($mean > $MAX_GIT) }")
  if [ "$is_bigger" = "1" ]; then MAX_GIT="$mean"; fi
done < <(extract_results "$GIT_JSON")

echo "| Engine | Mean | σ | Min | Max | |"
echo "|--------|-----:|--:|----:|----:|---|"

for i in "${!G_NAMES[@]}"; do
  name="${G_NAMES[$i]}"
  mean_ms=$(fmt_ms "${G_MEANS[$i]}")
  std_ms=$(fmt_ms "${G_STDDEVS[$i]}")
  min_ms=$(fmt_ms "${G_MINS[$i]}")
  max_ms=$(fmt_ms "${G_MAXS[$i]}")
  chart=$(bar "${G_MEANS[$i]}" "$MAX_GIT" 30)
  printf "| **%s** | %sms | ±%sms | %sms | %sms | \`%s\` |\n" \
    "$name" "$mean_ms" "$std_ms" "$min_ms" "$max_ms" "$chart"
done

echo ""

# Git overhead analysis
if [ ${#G_NAMES[@]} -ge 2 ] && [ ${#R_NAMES[@]} -ge 2 ]; then
  echo "### Git Overhead"
  echo ""
  echo "Delta between render-only and with-git benchmarks. Shows the cost of git operations per engine."
  echo ""
  echo "| Engine | Render | With Git | Git Cost | Library |"
  echo "|--------|-------:|---------:|---------:|---------|"

  for i in "${!G_NAMES[@]}"; do
    name="${G_NAMES[$i]}"
    git_ms=$(fmt_ms "${G_MEANS[$i]}")

    # Find matching render result
    render_ms="—"
    delta="—"
    for j in "${!R_NAMES[@]}"; do
      if [ "${R_NAMES[$j]}" = "$name" ]; then
        render_ms=$(fmt_ms "${R_MEANS[$j]}")
        delta=$(awk "BEGIN { printf \"%.1f\", (${G_MEANS[$i]} - ${R_MEANS[$j]}) * 1000 }")
        break
      fi
    done

    # Engine library info
    case "$name" in
      rust)   lib="gix (pure Rust)" ;;
      go)     lib="go-git (pure Go)" ;;
      bash)   lib="git CLI (7 subprocesses)" ;;
      python) lib="git CLI (5-8 subprocesses)" ;;
      *)      lib="—" ;;
    esac

    printf "| **%s** | %sms | %sms | +%sms | %s |\n" \
      "$name" "$render_ms" "$git_ms" "$delta" "$lib"
  done
  echo ""
fi

# Summary
echo "## Key Takeaways"
echo ""

# Find fastest render and git engines
if [ ${#R_NAMES[@]} -ge 1 ] && [ ${#G_NAMES[@]} -ge 1 ]; then
  fastest_render_idx=0
  for i in "${!R_MEANS[@]}"; do
    is_faster=$(awk "BEGIN { print (${R_MEANS[$i]} < ${R_MEANS[$fastest_render_idx]}) }")
    [ "$is_faster" = "1" ] && fastest_render_idx=$i
  done

  fastest_git_idx=0
  for i in "${!G_MEANS[@]}"; do
    is_faster=$(awk "BEGIN { print (${G_MEANS[$i]} < ${G_MEANS[$fastest_git_idx]}) }")
    [ "$is_faster" = "1" ] && fastest_git_idx=$i
  done

  fr_ms=$(fmt_ms "${R_MEANS[$fastest_render_idx]}")
  fg_ms=$(fmt_ms "${G_MEANS[$fastest_git_idx]}")

  echo "- **Fastest render**: ${R_NAMES[$fastest_render_idx]} at ${fr_ms}ms"
  echo "- **Fastest with git**: ${G_NAMES[$fastest_git_idx]} at ${fg_ms}ms"

  # Slowest render for comparison
  slowest_render_idx=0
  for i in "${!R_MEANS[@]}"; do
    is_slower=$(awk "BEGIN { print (${R_MEANS[$i]} > ${R_MEANS[$slowest_render_idx]}) }")
    [ "$is_slower" = "1" ] && slowest_render_idx=$i
  done
  ratio=$(awk "BEGIN { printf \"%.0f\", ${R_MEANS[$slowest_render_idx]} / ${R_MEANS[$fastest_render_idx]} }")
  echo "- **Fastest vs slowest**: ${ratio}x difference (${R_NAMES[$fastest_render_idx]} vs ${R_NAMES[$slowest_render_idx]})"
fi

echo "- **Subprocess-free engines** (Rust, Go) eliminate fork+exec overhead entirely"
echo "- **Python startup** (~400ms) dominates — bytecode caching has no effect"
echo "- **gix** (Rust) adds near-zero git overhead; **go-git** (Go) adds ~70ms"
echo ""
echo "## Methodology"
echo ""
echo "- Tool: [hyperfine](https://github.com/sharkdp/hyperfine) with 5 warmup, 50+ measured runs"
echo "- Fixture: \`tests/fixtures/basic-session.json\` (standard session data)"
echo "- Git: real repository (actual git operations, not mocked)"
echo "- Cumulative stats: disabled (isolates render + git performance)"
echo "- Hardware: GitHub Actions \`ubuntu-latest\` (2-core x86_64)"
echo ""
echo "Run locally: \`make bench\`"
